datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

model User {
  id    String @id @default(cuid())
  email String @unique

  authenticationMethod      AuthenticationMethod
  accessToken               String?
  authenticationProfile     Json?
  authenticationExtraParams Json?

  displayName String?
  name        String?
  avatarUrl   String?

  admin Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organizations Organization[]
}

enum AuthenticationMethod {
  GITHUB
  MAGIC_LINK
}

model Organization {
  id    String @id @default(cuid())
  slug  String @unique
  title String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users          User[]
  workflows      Workflow[]
  environments   RuntimeEnvironment[]
  apiConnections APIConnection[]
  customEvents   CustomEvent[]
}

model APIConnection {
  id    String @id @default(cuid())
  title String

  apiIdentifier String
  status        APIConnectionStatus @default(CREATED)
  scopes        String[]
  type          APIConnectionType

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organization    Organization             @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  organizationId  String
  connectionSlots WorkflowConnectionSlot[]
}

enum APIConnectionType {
  HTTP
  GRAPHQL
}

enum APIConnectionStatus {
  CREATED
  CONNECTED
}

model RuntimeEnvironment {
  id     String @id @default(cuid())
  slug   String
  apiKey String @unique

  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  organizationId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  triggers     WorkflowTrigger[]
  customEvents CustomEvent[]
  runs         WorkflowRun[]

  @@unique([organizationId, slug])
}

model Workflow {
  id    String @id @default(cuid())
  slug  String
  title String

  packageJson Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  organizationId String

  triggers           WorkflowTrigger[]
  runs               WorkflowRun[]
  connectionSlots    WorkflowConnectionSlot[]
  registeredWebhooks RegisteredWebhook[] // Can have multiple because there are multiple environments

  @@unique([organizationId, slug])
}

model WorkflowTrigger {
  id String @id @default(cuid())

  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  workflowId String

  environment   RuntimeEnvironment @relation(fields: [environmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  environmentId String

  type   WorkflowTriggerType
  config Json
  status WorkflowTriggerStatus @default(CREATED)

  isDefault         Boolean                 @default(false)
  runs              WorkflowRun[]
  connectionSlot    WorkflowConnectionSlot?
  registeredWebhook RegisteredWebhook?

  @@unique([workflowId, environmentId])
}

enum WorkflowTriggerType {
  WEBHOOK
  SCHEDULE
  CUSTOM_EVENT
  HTTP_ENDPOINT
}

enum WorkflowTriggerStatus {
  CREATED
  CONNECTED
}

model WorkflowConnectionSlot {
  id String @id @default(cuid())

  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  workflowId String

  trigger   WorkflowTrigger? @relation(fields: [triggerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  triggerId String?          @unique

  connection   APIConnection? @relation(fields: [connectionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  connectionId String?

  slotName          String
  serviceIdentifier String
  auth              Json?

  registeredWebhook RegisteredWebhook?

  @@unique([workflowId, slotName])
}

model RegisteredWebhook {
  id String @id @default(cuid())

  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  workflowId String

  trigger   WorkflowTrigger @relation(fields: [triggerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  triggerId String          @unique

  connectionSlot   WorkflowConnectionSlot @relation(fields: [connectionSlotId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  connectionSlotId String                 @unique

  secret        String
  webhookConfig Json?
  status        RegisteredWebhookStatus @default(CREATED)
  connectedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum RegisteredWebhookStatus {
  CREATED
  CONNECTED
}

model CustomEvent {
  id        String   @id @default(cuid())
  name      String
  timestamp DateTime @default(now())
  payload   Json
  context   Json?

  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  organizationId String

  environment   RuntimeEnvironment @relation(fields: [environmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  environmentId String

  status CustomEventStatus @default(PENDING)
}

enum CustomEventStatus {
  PENDING
  PROCESSED
}

model WorkflowRun {
  id String @id @default(cuid())

  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  workflowId String

  trigger   WorkflowTrigger @relation(fields: [triggerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  triggerId String

  environment   RuntimeEnvironment @relation(fields: [environmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  environmentId String

  tasks WorkflowRunStep[]

  input   Json
  context Json?
  error   Json?

  status WorkflowRunStatus @default(PENDING)

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  startedAt  DateTime?
  finishedAt DateTime?

  isTest Boolean @default(false)
}

enum WorkflowRunStatus {
  PENDING
  RUNNING
  SUCCESS
  ERROR
}

model WorkflowRunStep {
  id String @id @default(cuid())

  run   WorkflowRun @relation(fields: [runId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  runId String

  type    WorkflowRunStepType
  input   Json?
  output  Json?
  context Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  startedAt  DateTime?
  finishedAt DateTime?
}

enum WorkflowRunStepType {
  OUTPUT
  LOG_MESSAGE
  DURABLE_DELAY
  CUSTOM_EVENT
}

//todo triggers are environment specific
//todo connections are shared between environments
//todo in the future, connections can be override per environment
//todo runs are environment specific
//todo Workflows have connection slots, which are filled with connections (can be empty)
//todo Workflow has one trigger (can also have a slot with connection)
//todo WorkflowRuns belong to a workflow + environment
